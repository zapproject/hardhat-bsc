{
  "language": "Solidity",
  "sources": {
    "contracts/nft/Decimal.sol": {
      "content": "/*\n    Copyright 2019 dYdX Trading Inc.\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.4;\npragma experimental ABIEncoderV2;\n\n/**\n * NOTE: This file is a clone of the dydx protocol's Decimal.sol contract. It was forked from https://github.com/dydxprotocol/solo\n * at commit 2d8454e02702fe5bc455b848556660629c3cad36\n *\n * It has not been modified other than to use a newer solidity in the pragma to match the rest of the contract suite of this project\n */\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {Math} from \"./Math.sol\";\n\n/**\n * @title Decimal\n *\n * Library that defines a fixed-point number with 18 decimal places.\n */\nlibrary Decimal {\n    using SafeMath for uint256;\n\n    // ============ Constants ============\n\n    uint256 constant BASE_POW = 18;\n    uint256 constant BASE = 10**BASE_POW;\n\n    // ============ Structs ============\n\n    struct D256 {\n        uint256 value;\n    }\n\n    // ============ Functions ============\n\n    function one() internal pure returns (D256 memory) {\n        return D256({value: BASE});\n    }\n\n    function onePlus(D256 memory d) internal pure returns (D256 memory) {\n        return D256({value: d.value.add(BASE)});\n    }\n\n    function mul(uint256 target, D256 memory d)\n        internal\n        pure\n        returns (uint256)\n    {\n        return Math.getPartial(target, d.value, BASE);\n    }\n\n    function div(uint256 target, D256 memory d)\n        internal\n        pure\n        returns (uint256)\n    {\n        return Math.getPartial(target, BASE, d.value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/nft/Math.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.4;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title Math\n *\n * Library for non-standard Math functions\n * NOTE: This file is a clone of the dydx protocol's Decimal.sol contract.\n * It was forked from https://github.com/dydxprotocol/solo at commit\n * 2d8454e02702fe5bc455b848556660629c3cad36. It has not been modified other than to use a\n * newer solidity in the pragma to match the rest of the contract suite of this project.\n */\nlibrary Math {\n    using SafeMath for uint256;\n\n    // ============ Library Functions ============\n\n    /*\n     * Return target * (numerator / denominator).\n     */\n    function getPartial(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    ) internal pure returns (uint256) {\n        return target.mul(numerator).div(denominator);\n    }\n\n    /*\n     * Return target * (numerator / denominator), but rounded up.\n     */\n    function getPartialRoundUp(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    ) internal pure returns (uint256) {\n        if (target == 0 || numerator == 0) {\n            // SafeMath will check for zero denominator\n            return SafeMath.div(0, denominator);\n        }\n        return target.mul(numerator).sub(1).div(denominator).add(1);\n    }\n\n    function to128(uint256 number) internal pure returns (uint128) {\n        uint128 result = uint128(number);\n        require(result == number, \"Math: Unsafe cast to uint128\");\n        return result;\n    }\n\n    function to96(uint256 number) internal pure returns (uint96) {\n        uint96 result = uint96(number);\n        require(result == number, \"Math: Unsafe cast to uint96\");\n        return result;\n    }\n\n    function to32(uint256 number) internal pure returns (uint32) {\n        uint32 result = uint32(number);\n        require(result == number, \"Math: Unsafe cast to uint32\");\n        return result;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n}\n"
    },
    "contracts/nft/ZapMedia.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\npragma experimental ABIEncoderV2;\n\nimport {ERC721Burnable} from \"./ERC721Burnable.sol\";\nimport {ERC721} from \"./ERC721.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Counters} from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {Decimal} from \"./Decimal.sol\";\nimport {IMarket} from \"./interfaces/IMarket.sol\";\nimport \"./interfaces/IMedia.sol\";\n\n/**\n * @title A media value system, with perpetual equity to creators\n * @notice This contract provides an interface to mint media with a market\n * owned by the creator.\n */\nabstract contract ZapMedia is IMedia, ERC721Burnable, ReentrancyGuard {\n    using Counters for Counters.Counter;\n    using SafeMath for uint256;\n\n    /* *******\n     * Globals\n     * *******\n     */\n\n    // Address for the market\n    address public marketContract;\n\n    // Mapping from token to previous owner of the token\n    mapping(uint256 => address) public previousTokenOwners;\n\n    // Mapping from token id to creator address\n    mapping(uint256 => address) public tokenCreators;\n\n    // Mapping from creator address to their (enumerable) set of created tokens\n    mapping(address => EnumerableSet.UintSet) private _creatorTokens;\n\n    // Mapping from token id to sha256 hash of content\n    mapping(uint256 => bytes32) public tokenContentHashes;\n\n    // Mapping from token id to sha256 hash of metadata\n    mapping(uint256 => bytes32) public tokenMetadataHashes;\n\n    // Mapping from token id to metadataURI\n    mapping(uint256 => string) private _tokenMetadataURIs;\n\n    // Mapping from contentHash to bool\n    mapping(bytes32 => bool) private _contentHashes;\n\n    //keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;\n\n    //keccak256(\"MintWithSig(bytes32 contentHash,bytes32 metadataHash,uint256 creatorShare,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant MINT_WITH_SIG_TYPEHASH =\n        0x2952e482b8e2b192305f87374d7af45dc2eafafe4f50d26a0c02e90f2fdbe14b;\n\n    // Mapping from address to token id to permit nonce\n    mapping(address => mapping(uint256 => uint256)) public permitNonces;\n\n    // Mapping from address to mint with sig nonce\n    mapping(address => uint256) public mintWithSigNonces;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *     bytes4(keccak256('tokenMetadataURI(uint256)')) == 0x157c3df9\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd ^ 0x157c3df9 == 0x4e222e66\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x4e222e66;\n\n    Counters.Counter private _tokenIdTracker;\n\n    /* *********\n     * Modifiers\n     * *********\n     */\n\n    /**\n     * @notice Require that the token has not been burned and has been minted\n     */\n    modifier onlyExistingToken(uint256 tokenId) {\n        require(_exists(tokenId), \"Media: nonexistent token\");\n        _;\n    }\n\n    /**\n     * @notice Require that the token has had a content hash set\n     */\n    modifier onlyTokenWithContentHash(uint256 tokenId) {\n        require(\n            tokenContentHashes[tokenId] != 0,\n            \"Media: token does not have hash of created content\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Require that the token has had a metadata hash set\n     */\n    modifier onlyTokenWithMetadataHash(uint256 tokenId) {\n        require(\n            tokenMetadataHashes[tokenId] != 0,\n            \"Media: token does not have hash of its metadata\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Ensure that the provided spender is the approved or the owner of\n     * the media for the specified tokenId\n     */\n    modifier onlyApprovedOrOwner(address spender, uint256 tokenId) {\n        require(\n            _isApprovedOrOwner(spender, tokenId),\n            \"Media: Only approved or owner\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Ensure the token has been created (even if it has been burned)\n     */\n    modifier onlyTokenCreated(uint256 tokenId) {\n        require(\n            _tokenIdTracker.current() > tokenId,\n            \"Media: token with that id does not exist\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Ensure that the provided URI is not empty\n     */\n    modifier onlyValidURI(string memory uri) {\n        require(\n            bytes(uri).length != 0,\n            \"Media: specified uri must be non-empty\"\n        );\n        _;\n    }\n\n    /**\n     * @notice On deployment, set the market contract address and register the\n     * ERC721 metadata interface\n     */\n    constructor(address marketContractAddr) ERC721(\"Zora\", \"ZORA\") {\n        marketContract = marketContractAddr;\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    }\n\n    /* **************\n     * View Functions\n     * **************\n     */\n\n    /**\n     * @notice return the URI for a particular piece of media with the specified tokenId\n     * @dev This function is an override of the base OZ implementation because we\n     * will return the tokenURI even if the media has been burned. In addition, this\n     * protocol does not support a base URI, so relevant conditionals are removed.\n     * @return the URI for a token\n     */\n    function tokenUri(uint256 tokenId)\n        public\n        view\n        onlyTokenCreated(tokenId)\n        returns (string memory)\n    {\n        string memory _tokenURI = _tokenURIs[tokenId];\n\n        return _tokenURI;\n    }\n\n    /**\n     * @notice Return the metadata URI for a piece of media given the token URI\n     * @return the metadata URI for the token\n     */\n    function tokenMetadataURI(uint256 tokenId)\n        external\n        view\n        override\n        onlyTokenCreated(tokenId)\n        returns (string memory)\n    {\n        return _tokenMetadataURIs[tokenId];\n    }\n\n    /* ****************\n     * Public Functions\n     * ****************\n     */\n\n    /**\n     * @notice see IMedia\n     */\n    function mint(MediaData memory data, IMarket.BidShares memory bidShares)\n        public\n        override\n        nonReentrant\n    {\n        _mintForCreator(msg.sender, data, bidShares);\n    }\n\n    /**\n     * @notice see IMedia\n     */\n    function mintWithSig(\n        address creator,\n        MediaData memory data,\n        IMarket.BidShares memory bidShares,\n        EIP712Signature memory sig\n    ) public override nonReentrant {\n        require(\n            sig.deadline == 0 || sig.deadline >= block.timestamp,\n            \"Media: mintWithSig expired\"\n        );\n\n        bytes32 domainSeparator = _calculateDomainSeparator();\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                keccak256(\n                    abi.encode(\n                        MINT_WITH_SIG_TYPEHASH,\n                        data.contentHash,\n                        data.metadataHash,\n                        bidShares.creator.value,\n                        mintWithSigNonces[creator]++,\n                        sig.deadline\n                    )\n                )\n            )\n        );\n\n        address recoveredAddress = ecrecover(digest, sig.v, sig.r, sig.s);\n\n        require(\n            recoveredAddress != address(0) && creator == recoveredAddress,\n            \"Media: Signature invalid\"\n        );\n\n        _mintForCreator(recoveredAddress, data, bidShares);\n    }\n\n    /**\n     * @notice see IMedia\n     */\n    function auctionTransfer(uint256 tokenId, address recipient)\n        external\n        override\n    {\n        require(msg.sender == marketContract, \"Media: only market contract\");\n        previousTokenOwners[tokenId] = ownerOf(tokenId);\n        _safeTransfer(ownerOf(tokenId), recipient, tokenId, \"\");\n    }\n\n    /**\n     * @notice see IMedia\n     */\n    function setAsk(uint256 tokenId, IMarket.Ask memory ask)\n        public\n        override\n        nonReentrant\n        onlyApprovedOrOwner(msg.sender, tokenId)\n    {\n        IMarket(marketContract).setAsk(tokenId, ask);\n    }\n\n    /**\n     * @notice see IMedia\n     */\n    function removeAsk(uint256 tokenId)\n        external\n        override\n        nonReentrant\n        onlyApprovedOrOwner(msg.sender, tokenId)\n    {\n        IMarket(marketContract).removeAsk(tokenId);\n    }\n\n    /**\n     * @notice see IMedia\n     */\n    function setBid(uint256 tokenId, IMarket.Bid memory bid)\n        public\n        override\n        nonReentrant\n        onlyExistingToken(tokenId)\n    {\n        require(msg.sender == bid.bidder, \"Market: Bidder must be msg sender\");\n        IMarket(marketContract).setBid(tokenId, bid, msg.sender);\n    }\n\n    /**\n     * @notice see IMedia\n     */\n    function removeBid(uint256 tokenId)\n        external\n        override\n        nonReentrant\n        onlyTokenCreated(tokenId)\n    {\n        IMarket(marketContract).removeBid(tokenId, msg.sender);\n    }\n\n    /**\n     * @notice see IMedia\n     */\n    function acceptBid(uint256 tokenId, IMarket.Bid memory bid)\n        public\n        override\n        nonReentrant\n        onlyApprovedOrOwner(msg.sender, tokenId)\n    {\n        IMarket(marketContract).acceptBid(tokenId, bid);\n    }\n\n    /**\n     * @notice Burn a token.\n     * @dev Only callable if the media owner is also the creator.\n     */\n    function burn(uint256 tokenId)\n        public\n        override\n        nonReentrant\n        onlyExistingToken(tokenId)\n        onlyApprovedOrOwner(msg.sender, tokenId)\n    {\n        address owner = ownerOf(tokenId);\n\n        require(\n            tokenCreators[tokenId] == owner,\n            \"Media: owner is not creator of media\"\n        );\n\n        _burn(tokenId);\n    }\n\n    /**\n     * @notice Revoke the approvals for a token. The provided `approve` function is not sufficient\n     * for this protocol, as it does not allow an approved address to revoke it's own approval.\n     * In instances where a 3rd party is interacting on a user's behalf via `permit`, they should\n     * revoke their approval once their task is complete as a best practice.\n     */\n    function revokeApproval(uint256 tokenId) external override nonReentrant {\n        require(\n            msg.sender == getApproved(tokenId),\n            \"Media: caller not approved address\"\n        );\n        _approve(address(0), tokenId);\n    }\n\n    /**\n     * @notice see IMedia\n     * @dev only callable by approved or owner\n     */\n    function updateTokenURI(uint256 tokenId, string calldata tokenURI)\n        external\n        override\n        nonReentrant\n        onlyApprovedOrOwner(msg.sender, tokenId)\n        onlyTokenWithContentHash(tokenId)\n        onlyValidURI(tokenURI)\n    {\n        _setTokenURI(tokenId, tokenURI);\n        emit TokenURIUpdated(tokenId, msg.sender, tokenURI);\n    }\n\n    /**\n     * @notice see IMedia\n     * @dev only callable by approved or owner\n     */\n    function updateTokenMetadataURI(\n        uint256 tokenId,\n        string calldata metadataURI\n    )\n        external\n        override\n        nonReentrant\n        onlyApprovedOrOwner(msg.sender, tokenId)\n        onlyTokenWithMetadataHash(tokenId)\n        onlyValidURI(metadataURI)\n    {\n        _setTokenMetadataURI(tokenId, metadataURI);\n        emit TokenMetadataURIUpdated(tokenId, msg.sender, metadataURI);\n    }\n\n    /**\n     * @notice See IMedia\n     * @dev This method is loosely based on the permit for ERC-20 tokens in  EIP-2612, but modified\n     * for ERC-721.\n     */\n    function permit(\n        address spender,\n        uint256 tokenId,\n        EIP712Signature memory sig\n    ) public override nonReentrant onlyExistingToken(tokenId) {\n        require(\n            sig.deadline == 0 || sig.deadline >= block.timestamp,\n            \"Media: Permit expired\"\n        );\n        require(spender != address(0), \"Media: spender cannot be 0x0\");\n        bytes32 domainSeparator = _calculateDomainSeparator();\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        spender,\n                        tokenId,\n                        permitNonces[ownerOf(tokenId)][tokenId]++,\n                        sig.deadline\n                    )\n                )\n            )\n        );\n\n        address recoveredAddress = ecrecover(digest, sig.v, sig.r, sig.s);\n\n        require(\n            recoveredAddress != address(0) &&\n                ownerOf(tokenId) == recoveredAddress,\n            \"Media: Signature invalid\"\n        );\n\n        _approve(spender, tokenId);\n    }\n\n    /* *****************\n     * Private Functions\n     * *****************\n     */\n\n    /**\n     * @notice Creates a new token for `creator`. Its token ID will be automatically\n     * assigned (and available on the emitted {IERC721-Transfer} event), and the token\n     * URI autogenerated based on the base URI passed at construction.\n     *\n     * See {ERC721-_safeMint}.\n     *\n     * On mint, also set the sha256 hashes of the content and its metadata for integrity\n     * checks, along with the initial URIs to point to the content and metadata. Attribute\n     * the token ID to the creator, mark the content hash as used, and set the bid shares for\n     * the media's market.\n     *\n     * Note that although the content hash must be unique for future mints to prevent duplicate media,\n     * metadata has no such requirement.\n     */\n    function _mintForCreator(\n        address creator,\n        MediaData memory data,\n        IMarket.BidShares memory bidShares\n    ) internal onlyValidURI(data.tokenURI) onlyValidURI(data.metadataURI) {\n        require(data.contentHash != 0, \"Media: content hash must be non-zero\");\n        require(\n            _contentHashes[data.contentHash] == false,\n            \"Media: a token has already been created with this content hash\"\n        );\n        require(\n            data.metadataHash != 0,\n            \"Media: metadata hash must be non-zero\"\n        );\n\n        uint256 tokenId = _tokenIdTracker.current();\n\n        _safeMint(creator, tokenId);\n        _tokenIdTracker.increment();\n        _setTokenContentHash(tokenId, data.contentHash);\n        _setTokenMetadataHash(tokenId, data.metadataHash);\n        _setTokenMetadataURI(tokenId, data.metadataURI);\n        _setTokenURI(tokenId, data.tokenURI);\n        // _creatorTokens[creator].add(tokenId);\n        _contentHashes[data.contentHash] = true;\n\n        tokenCreators[tokenId] = creator;\n        previousTokenOwners[tokenId] = creator;\n        IMarket(marketContract).setBidShares(tokenId, bidShares);\n    }\n\n    function _setTokenContentHash(uint256 tokenId, bytes32 contentHash)\n        internal\n        virtual\n        onlyExistingToken(tokenId)\n    {\n        tokenContentHashes[tokenId] = contentHash;\n    }\n\n    function _setTokenMetadataHash(uint256 tokenId, bytes32 metadataHash)\n        internal\n        virtual\n        onlyExistingToken(tokenId)\n    {\n        tokenMetadataHashes[tokenId] = metadataHash;\n    }\n\n    function _setTokenMetadataURI(uint256 tokenId, string memory metadataURI)\n        internal\n        virtual\n        onlyExistingToken(tokenId)\n    {\n        _tokenMetadataURIs[tokenId] = metadataURI;\n    }\n\n    /**\n     * @notice Destroys `tokenId`.\n     * @dev We modify the OZ _burn implementation to\n     * maintain metadata and to remove the\n     * previous token owner from the piece\n     */\n    function _burn(uint256 tokenId) internal override {\n        string memory tokenURI = _tokenURIs[tokenId];\n\n        super._burn(tokenId);\n\n        if (bytes(tokenURI).length != 0) {\n            _tokenURIs[tokenId] = tokenURI;\n        }\n\n        delete previousTokenOwners[tokenId];\n    }\n\n    /**\n     * @notice transfer a token and remove the ask for it.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        IMarket(marketContract).removeAsk(tokenId);\n\n        super._transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Calculates EIP712 DOMAIN_SEPARATOR based on the current contract and chain ID.\n     */\n    function _calculateDomainSeparator() internal view returns (bytes32) {\n        uint256 chainID;\n        /* solium-disable-next-line */\n        assembly {\n            chainID := chainid()\n        }\n\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                    ),\n                    keccak256(bytes(\"Zora\")),\n                    keccak256(bytes(\"1\")),\n                    chainID,\n                    address(this)\n                )\n            );\n    }\n}\n"
    },
    "contracts/nft/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * NOTE: This file is a clone of the OpenZeppelin ERC721Burnable.sol contract. It was forked from https://github.com/OpenZeppelin/openzeppelin-contracts\n * at commit 1ada3b633e5bfd9d4ffe0207d64773a11f5a7c40\n *\n * It was cloned in order to ensure it imported from the cloned ERC721.sol file. No other modifications have been made.\n */\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"./ERC721.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"ERC721Burnable: caller is not owner nor approved\"\n        );\n        _burn(tokenId);\n    }\n}\n"
    },
    "contracts/nft/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.4;\n\n/**\n * NOTE: This file is a clone of the OpenZeppelin ERC721.sol contract. It was forked from https://github.com/OpenZeppelin/openzeppelin-contracts\n * at commit 1ada3b633e5bfd9d4ffe0207d64773a11f5a7c40\n *\n *\n * The following functions needed to be modified, prompting this clone:\n *  - `_tokenURIs` visibility was changed from private to internal to support updating URIs after minting\n *  - `_baseURI` visibiility was changed from private to internal to support fetching token URI even after the token was burned\n *  - `_INTERFACE_ID_ERC721_METADATA` is no longer registered as an interface because _tokenURI now returns raw content instead of a JSON file, and supports updatable URIs\n *  - `_approve` visibility was changed from private to internal to support EIP-2612 flavored permits and approval revocation by an approved address\n */\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is\n    Context,\n    ERC165Storage,\n    IERC721,\n    IERC721Metadata,\n    IERC721Enumerable\n{\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using Strings for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping(address => EnumerableSet.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) internal _tokenURIs;\n\n    // Base URI\n    string internal _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory __name, string memory __symbol) {\n        _name = __name;\n        _symbol = __symbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view override returns (uint256) {\n        require(\n            owner != address(0),\n            \"ERC721: balance query for the zero address\"\n        );\n\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenID) public view override returns (address) {\n        return\n            _tokenOwners.get(\n                tokenID,\n                \"ERC721: owner query for nonexistent token\"\n            );\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenID)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        require(\n            _exists(tokenID),\n            \"ERC721Metadata: URI query for nonexistent token\"\n        );\n\n        string memory _tokenURI = _tokenURIs[tokenID];\n\n        // If there is no base URI, return the token URI.\n        if (bytes(_baseURI).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(_baseURI, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(_baseURI, tokenID.toString()));\n    }\n\n    /**\n     * @dev Returns the base URI set via {_setBaseURI}. This will be\n     * automatically added as a prefix in {tokenURI} to each token's URI, or\n     * to the token ID if no specific URI is set for that token ID.\n     */\n    function baseURI() public view returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        // _tokenOwners are indexed by tokenIDs, so .length() returns the number of tokenIDs\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        (uint256 tokenID, ) = _tokenOwners.at(index);\n        return tokenID;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenID) public virtual override {\n        address owner = ownerOf(tokenID);\n\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenID);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenID)\n        public\n        view\n        override\n        returns (address)\n    {\n        require(\n            _exists(tokenID),\n            \"ERC721: approved query for nonexistent token\"\n        );\n\n        return _tokenApprovals[tokenID];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved)\n        public\n        virtual\n        override\n    {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenID\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenID),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n\n        _transfer(from, to, tokenID);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenID\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenID, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenID,\n        bytes memory _data\n    ) public virtual override {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenID),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n        _safeTransfer(from, to, tokenID, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenID` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenID` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenID,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenID);\n        require(\n            _checkOnERC721Received(from, to, tokenID, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Returns whether `tokenID` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenID) internal view returns (bool) {\n        return _tokenOwners.contains(tokenID);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenID`.\n     *\n     * Requirements:\n     *\n     * - `tokenID` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenID)\n        internal\n        view\n        returns (bool)\n    {\n        require(\n            _exists(tokenID),\n            \"ERC721: operator query for nonexistent token\"\n        );\n        address owner = ownerOf(tokenID);\n        return (spender == owner ||\n            getApproved(tokenID) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Public method which returns whether `spender` is allowed to manage `tokenID`.\n     *\n     * Requirements:\n     *\n     * - `tokenID` must exist.\n     */\n    function isApprovedOrOwner(address spender, uint256 tokenID)\n        public\n        view\n        returns (bool)\n    {\n        return _isApprovedOrOwner(spender, tokenID);\n    }\n\n    /**\n     * @dev Safely mints `tokenID` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenID` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenID) internal virtual {\n        _safeMint(to, tokenID, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenID,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenID);\n        require(\n            _checkOnERC721Received(address(0), to, tokenID, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenID` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenID` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenID) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenID), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenID);\n\n        _holderTokens[to].add(tokenID);\n\n        _tokenOwners.set(tokenID, to);\n\n        emit Transfer(address(0), to, tokenID);\n    }\n\n    /**\n     * @dev Destroys `tokenID`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenID` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenID) internal virtual {\n        address owner = ownerOf(tokenID);\n\n        _beforeTokenTransfer(owner, address(0), tokenID);\n\n        // Clear approvals\n        _approve(address(0), tokenID);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenID]).length != 0) {\n            delete _tokenURIs[tokenID];\n        }\n\n        _holderTokens[owner].remove(tokenID);\n\n        _tokenOwners.remove(tokenID);\n\n        emit Transfer(owner, address(0), tokenID);\n    }\n\n    /**\n     * @dev Transfers `tokenID` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenID` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenID\n    ) internal virtual {\n        require(\n            ownerOf(tokenID) == from,\n            \"ERC721: transfer of token that is not own\"\n        );\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenID);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenID);\n\n        _holderTokens[from].remove(tokenID);\n        _holderTokens[to].add(tokenID);\n\n        _tokenOwners.set(tokenID, to);\n\n        emit Transfer(from, to, tokenID);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenID`.\n     *\n     * Requirements:\n     *\n     * - `tokenID` must exist.\n     */\n    function _setTokenURI(uint256 tokenID, string memory _tokenURI)\n        internal\n        virtual\n    {\n        require(\n            _exists(tokenID),\n            \"ERC721Metadata: URI set of nonexistent token\"\n        );\n        _tokenURIs[tokenID] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenID uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenID,\n        bytes memory _data\n    ) private returns (bool) {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(\n            abi.encodeWithSelector(\n                IERC721Receiver(to).onERC721Received.selector,\n                _msgSender(),\n                from,\n                tokenID,\n                _data\n            ),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    function _approve(address to, uint256 tokenID) internal {\n        _tokenApprovals[tokenID] = to;\n        emit Approval(ownerOf(tokenID), to, tokenID);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenID` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenID` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenID` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenID\n    ) internal virtual {}\n}"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute.\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/nft/interfaces/IMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.4;\npragma experimental ABIEncoderV2;\n\nimport {Decimal} from \"../Decimal.sol\";\n\n/**\n * @title Interface for Zora Protocol's Market\n */\ninterface IMarket {\n    struct Bid {\n        // Amount of the currency being bid\n        uint256 amount;\n        // Address to the ERC20 token being used to bid\n        address currency;\n        // Address of the bidder\n        address bidder;\n        // Address of the recipient\n        address recipient;\n        // % of the next sale to award the current owner\n        Decimal.D256 sellOnShare;\n    }\n\n    struct Ask {\n        // Amount of the currency being asked\n        uint256 amount;\n        // Address to the ERC20 token being asked\n        address currency;\n    }\n\n    struct BidShares {\n        // % of sale value that goes to the _previous_ owner of the nft\n        Decimal.D256 prevOwner;\n        // % of sale value that goes to the original creator of the nft\n        Decimal.D256 creator;\n        // % of sale value that goes to the seller (current owner) of the nft\n        Decimal.D256 owner;\n    }\n\n    event BidCreated(uint256 indexed tokenId, Bid bid);\n    event BidRemoved(uint256 indexed tokenId, Bid bid);\n    event BidFinalized(uint256 indexed tokenId, Bid bid);\n    event AskCreated(uint256 indexed tokenId, Ask ask);\n    event AskRemoved(uint256 indexed tokenId, Ask ask);\n    event BidShareUpdated(uint256 indexed tokenId, BidShares bidShares);\n\n    function bidForTokenBidder(uint256 tokenId, address bidder)\n        external\n        view\n        returns (Bid memory);\n\n    function currentAskForToken(uint256 tokenId)\n        external\n        view\n        returns (Ask memory);\n\n    function bidSharesForToken(uint256 tokenId)\n        external\n        view\n        returns (BidShares memory);\n\n    function isValidBid(uint256 tokenId, uint256 bidAmount)\n        external\n        view\n        returns (bool);\n\n    function isValidBidShares(BidShares calldata bidShares)\n        external\n        pure\n        returns (bool);\n\n    function splitShare(Decimal.D256 calldata sharePercentage, uint256 amount)\n        external\n        pure\n        returns (uint256);\n\n    function configure(address mediaContractAddress) external;\n\n    function setBidShares(uint256 tokenId, BidShares calldata bidShares)\n        external;\n\n    function setAsk(uint256 tokenId, Ask calldata ask) external;\n\n    function removeAsk(uint256 tokenId) external;\n\n    function setBid(\n        uint256 tokenId,\n        Bid calldata bid,\n        address spender\n    ) external;\n\n    function removeBid(uint256 tokenId, address bidder) external;\n\n    function acceptBid(uint256 tokenId, Bid calldata expectedBid) external;\n}\n"
    },
    "contracts/nft/interfaces/IMedia.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.4;\npragma experimental ABIEncoderV2;\n\nimport {IMarket} from \"./IMarket.sol\";\n\n/**\n * @title Interface for Zora Protocol's Media\n */\ninterface IMedia {\n    struct EIP712Signature {\n        uint256 deadline;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct MediaData {\n        // A valid URI of the content represented by this token\n        string tokenURI;\n        // A valid URI of the metadata associated with this token\n        string metadataURI;\n        // A SHA256 hash of the content pointed to by tokenURI\n        bytes32 contentHash;\n        // A SHA256 hash of the content pointed to by metadataURI\n        bytes32 metadataHash;\n    }\n\n    event TokenURIUpdated(uint256 indexed _tokenId, address owner, string _uri);\n    event TokenMetadataURIUpdated(\n        uint256 indexed _tokenId,\n        address owner,\n        string _uri\n    );\n\n    /**\n     * @notice Return the metadata URI for a piece of media given the token URI\n     */\n    function tokenMetadataURI(uint256 tokenId)\n        external\n        view\n        returns (string memory);\n\n    /**\n     * @notice Mint new media for msg.sender.\n     */\n    function mint(MediaData calldata data, IMarket.BidShares calldata bidShares)\n        external;\n\n    /**\n     * @notice EIP-712 mintWithSig method. Mints new media for a creator given a valid signature.\n     */\n    function mintWithSig(\n        address creator,\n        MediaData calldata data,\n        IMarket.BidShares calldata bidShares,\n        EIP712Signature calldata sig\n    ) external;\n\n    /**\n     * @notice Transfer the token with the given ID to a given address.\n     * Save the previous owner before the transfer, in case there is a sell-on fee.\n     * @dev This can only be called by the auction contract specified at deployment\n     */\n    function auctionTransfer(uint256 tokenId, address recipient) external;\n\n    /**\n     * @notice Set the ask on a piece of media\n     */\n    function setAsk(uint256 tokenId, IMarket.Ask calldata ask) external;\n\n    /**\n     * @notice Remove the ask on a piece of media\n     */\n    function removeAsk(uint256 tokenId) external;\n\n    /**\n     * @notice Set the bid on a piece of media\n     */\n    function setBid(uint256 tokenId, IMarket.Bid calldata bid) external;\n\n    /**\n     * @notice Remove the bid on a piece of media\n     */\n    function removeBid(uint256 tokenId) external;\n\n    function acceptBid(uint256 tokenId, IMarket.Bid calldata bid) external;\n\n    /**\n     * @notice Revoke approval for a piece of media\n     */\n    function revokeApproval(uint256 tokenId) external;\n\n    /**\n     * @notice Update the token URI\n     */\n    function updateTokenURI(uint256 tokenId, string calldata tokenURI) external;\n\n    /**\n     * @notice Update the token metadata uri\n     */\n    function updateTokenMetadataURI(\n        uint256 tokenId,\n        string calldata metadataURI\n    ) external;\n\n    /**\n     * @notice EIP-712 permit method. Sets an approved spender given a valid signature.\n     */\n    function permit(\n        address spender,\n        uint256 tokenId,\n        EIP712Signature calldata sig\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ERC165.sol\";\n\n/**\n * @dev Storage based implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165Storage is ERC165 {\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/nft/ZapMarket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.4;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Decimal} from \"./Decimal.sol\";\nimport {ZapMedia} from \"./ZapMedia.sol\";\nimport {IMarket} from \"./interfaces/IMarket.sol\";\n\n/**\n * @title A Market for pieces of media\n * @notice This contract contains all of the market logic for Media\n */\ncontract ZapMarket is IMarket {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /* *******\n     * Globals\n     * *******\n     */\n    // Address of the media contract that can call this market\n    address public mediaContract;\n\n    // Deployment Address\n    address private _owner;\n\n    // Mapping from token to mapping from bidder to bid\n    mapping(uint256 => mapping(address => Bid)) private _tokenBidders;\n\n    // Mapping from token to the bid shares for the token\n    mapping(uint256 => BidShares) private _bidShares;\n\n    // Mapping from token to the current ask for the token\n    mapping(uint256 => Ask) private _tokenAsks;\n\n    /* *********\n     * Modifiers\n     * *********\n     */\n\n    /**\n     * @notice require that the msg.sender is the configured media contract\n     */\n    modifier onlyMediaCaller() {\n        require(mediaContract == msg.sender, \"Market: Only media contract\");\n        _;\n    }\n\n    /* ****************\n     * View Functions\n     * ****************\n     */\n    function bidForTokenBidder(uint256 tokenId, address bidder)\n        external\n        view\n        override\n        returns (Bid memory)\n    {\n        return _tokenBidders[tokenId][bidder];\n    }\n\n    function currentAskForToken(uint256 tokenId)\n        external\n        view\n        override\n        returns (Ask memory)\n    {\n        return _tokenAsks[tokenId];\n    }\n\n    function bidSharesForToken(uint256 tokenId)\n        public\n        view\n        override\n        returns (BidShares memory)\n    {\n        return _bidShares[tokenId];\n    }\n\n    /**\n     * @notice Validates that the bid is valid by ensuring that the bid amount can be split perfectly into all the bid shares.\n     *  We do this by comparing the sum of the individual share values with the amount and ensuring they are equal. Because\n     *  the splitShare function uses integer division, any inconsistencies with the original and split sums would be due to\n     *  a bid splitting that does not perfectly divide the bid amount.\n     */\n    function isValidBid(uint256 tokenId, uint256 bidAmount)\n        public\n        view\n        override\n        returns (bool)\n    {\n        BidShares memory bidShares = bidSharesForToken(tokenId);\n        require(\n            isValidBidShares(bidShares),\n            \"Market: Invalid bid shares for token\"\n        );\n        return\n            bidAmount != 0 &&\n            (bidAmount ==\n                splitShare(bidShares.creator, bidAmount)\n                    .add(splitShare(bidShares.prevOwner, bidAmount))\n                    .add(splitShare(bidShares.owner, bidAmount)));\n    }\n\n    /**\n     * @notice Validates that the provided bid shares sum to 100\n     */\n    function isValidBidShares(BidShares memory bidShares)\n        public\n        pure\n        override\n        returns (bool)\n    {\n        return\n            bidShares.creator.value.add(bidShares.owner.value).add(\n                bidShares.prevOwner.value\n            ) == uint256(100).mul(Decimal.BASE);\n    }\n\n    /**\n     * @notice return a % of the specified amount. This function is used to split a bid into shares\n     * for a media's shareholders.\n     */\n    function splitShare(Decimal.D256 memory sharePercentage, uint256 amount)\n        public\n        pure\n        override\n        returns (uint256)\n    {\n        return Decimal.mul(amount, sharePercentage).div(100);\n    }\n\n    /* ****************\n     * Public Functions\n     * ****************\n     */\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    /**\n     * @notice Sets the media contract address. This address is the only permitted address that\n     * can call the mutable functions. This method can only be called once.\n     */\n    function configure(address mediaContractAddress) external override {\n        require(msg.sender == _owner, \"Market: Only owner\");\n        require(mediaContract == address(0), \"Market: Already configured\");\n        require(\n            mediaContractAddress != address(0),\n            \"Market: cannot set media contract as zero address\"\n        );\n\n        mediaContract = mediaContractAddress;\n    }\n\n    /**\n     * @notice Sets bid shares for a particular tokenId. These bid shares must\n     * sum to 100.\n     */\n    function setBidShares(uint256 tokenId, BidShares memory bidShares)\n        public\n        override\n        onlyMediaCaller\n    {\n        require(\n            isValidBidShares(bidShares),\n            \"Market: Invalid bid shares, must sum to 100\"\n        );\n        _bidShares[tokenId] = bidShares;\n        emit BidShareUpdated(tokenId, bidShares);\n    }\n\n    /**\n     * @notice Sets the ask on a particular media. If the ask cannot be evenly split into the media's\n     * bid shares, this reverts.\n     */\n    function setAsk(uint256 tokenId, Ask memory ask)\n        public\n        override\n        onlyMediaCaller\n    {\n        require(\n            isValidBid(tokenId, ask.amount),\n            \"Market: Ask invalid for share splitting\"\n        );\n\n        _tokenAsks[tokenId] = ask;\n        emit AskCreated(tokenId, ask);\n    }\n\n    /**\n     * @notice removes an ask for a token and emits an AskRemoved event\n     */\n    function removeAsk(uint256 tokenId) external override onlyMediaCaller {\n        emit AskRemoved(tokenId, _tokenAsks[tokenId]);\n        delete _tokenAsks[tokenId];\n    }\n\n    /**\n     * @notice Sets the bid on a particular media for a bidder. The token being used to bid\n     * is transferred from the spender to this contract to be held until removed or accepted.\n     * If another bid already exists for the bidder, it is refunded.\n     */\n    function setBid(\n        uint256 tokenId,\n        Bid memory bid,\n        address spender\n    ) public override onlyMediaCaller {\n        BidShares memory bidShares = _bidShares[tokenId];\n        require(\n            bidShares.creator.value.add(bid.sellOnShare.value) <=\n                uint256(100).mul(Decimal.BASE),\n            \"Market: Sell on fee invalid for share splitting\"\n        );\n        require(bid.bidder != address(0), \"Market: bidder cannot be 0 address\");\n        require(bid.amount != 0, \"Market: cannot bid amount of 0\");\n        require(\n            bid.currency != address(0),\n            \"Market: bid currency cannot be 0 address\"\n        );\n        require(\n            bid.recipient != address(0),\n            \"Market: bid recipient cannot be 0 address\"\n        );\n\n        Bid storage existingBid = _tokenBidders[tokenId][bid.bidder];\n\n        // If there is an existing bid, refund it before continuing\n        if (existingBid.amount > 0) {\n            removeBid(tokenId, bid.bidder);\n        }\n\n        IERC20 token = IERC20(bid.currency);\n\n        // We must check the balance that was actually transferred to the market,\n        // as some tokens impose a transfer fee and would not actually transfer the\n        // full amount to the market, resulting in locked funds for refunds & bid acceptance\n        uint256 beforeBalance = token.balanceOf(address(this));\n        token.safeTransferFrom(spender, address(this), bid.amount);\n        uint256 afterBalance = token.balanceOf(address(this));\n        _tokenBidders[tokenId][bid.bidder] = Bid(\n            afterBalance.sub(beforeBalance),\n            bid.currency,\n            bid.bidder,\n            bid.recipient,\n            bid.sellOnShare\n        );\n        emit BidCreated(tokenId, bid);\n\n        // If a bid meets the criteria for an ask, automatically accept the bid.\n        // If no ask is set or the bid does not meet the requirements, ignore.\n        if (\n            _tokenAsks[tokenId].currency != address(0) &&\n            bid.currency == _tokenAsks[tokenId].currency &&\n            bid.amount >= _tokenAsks[tokenId].amount\n        ) {\n            // Finalize exchange\n            _finalizeNFTTransfer(tokenId, bid.bidder);\n        }\n    }\n\n    /**\n     * @notice Removes the bid on a particular media for a bidder. The bid amount\n     * is transferred from this contract to the bidder, if they have a bid placed.\n     */\n    function removeBid(uint256 tokenId, address bidder)\n        public\n        override\n        onlyMediaCaller\n    {\n        Bid storage bid = _tokenBidders[tokenId][bidder];\n        uint256 bidAmount = bid.amount;\n        address bidCurrency = bid.currency;\n\n        require(bid.amount > 0, \"Market: cannot remove bid amount of 0\");\n\n        IERC20 token = IERC20(bidCurrency);\n\n        emit BidRemoved(tokenId, bid);\n        delete _tokenBidders[tokenId][bidder];\n        token.safeTransfer(bidder, bidAmount);\n    }\n\n    /**\n     * @notice Accepts a bid from a particular bidder. Can only be called by the media contract.\n     * See {_finalizeNFTTransfer}\n     * Provided bid must match a bid in storage. This is to prevent a race condition\n     * where a bid may change while the acceptBid call is in transit.\n     * A bid cannot be accepted if it cannot be split equally into its shareholders.\n     * This should only revert in rare instances (example, a low bid with a zero-decimal token),\n     * but is necessary to ensure fairness to all shareholders.\n     */\n    function acceptBid(uint256 tokenId, Bid calldata expectedBid)\n        external\n        override\n        onlyMediaCaller\n    {\n        Bid memory bid = _tokenBidders[tokenId][expectedBid.bidder];\n        require(bid.amount > 0, \"Market: cannot accept bid of 0\");\n        require(\n            bid.amount == expectedBid.amount &&\n                bid.currency == expectedBid.currency &&\n                bid.sellOnShare.value == expectedBid.sellOnShare.value &&\n                bid.recipient == expectedBid.recipient,\n            \"Market: Unexpected bid found.\"\n        );\n        require(\n            isValidBid(tokenId, bid.amount),\n            \"Market: Bid invalid for share splitting\"\n        );\n\n        _finalizeNFTTransfer(tokenId, bid.bidder);\n    }\n\n    /**\n     * @notice Given a token ID and a bidder, this method transfers the value of\n     * the bid to the shareholders. It also transfers the ownership of the media\n     * to the bid recipient. Finally, it removes the accepted bid and the current ask.\n     */\n    function _finalizeNFTTransfer(uint256 tokenId, address bidder) private {\n        Bid memory bid = _tokenBidders[tokenId][bidder];\n        BidShares storage bidShares = _bidShares[tokenId];\n\n        IERC20 token = IERC20(bid.currency);\n\n        // Transfer bid share to owner of media\n        token.safeTransfer(\n            IERC721(mediaContract).ownerOf(tokenId),\n            splitShare(bidShares.owner, bid.amount)\n        );\n        // Transfer bid share to creator of media\n        token.safeTransfer(\n            ZapMedia(mediaContract).tokenCreators(tokenId),\n            splitShare(bidShares.creator, bid.amount)\n        );\n        // Transfer bid share to previous owner of media (if applicable)\n        token.safeTransfer(\n            ZapMedia(mediaContract).previousTokenOwners(tokenId),\n            splitShare(bidShares.prevOwner, bid.amount)\n        );\n\n        // Transfer media to bid recipient\n        ZapMedia(mediaContract).auctionTransfer(tokenId, bid.recipient);\n\n        // Calculate the bid share for the new owner,\n        // equal to 100 - creatorShare - sellOnShare\n        bidShares.owner = Decimal.D256(\n            uint256(100)\n                .mul(Decimal.BASE)\n                .sub(_bidShares[tokenId].creator.value)\n                .sub(bid.sellOnShare.value)\n        );\n        // Set the previous owner share to the accepted bid's sell-on fee\n        bidShares.prevOwner = bid.sellOnShare;\n\n        // Remove the accepted bid\n        delete _tokenBidders[tokenId][bidder];\n\n        emit BidShareUpdated(tokenId, bidShares);\n        emit BidFinalized(tokenId, bid);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "contracts/nft/ZapAuction.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\ncontract ZapAuction is IERC721Receiver {\n    struct AuctionInfo {\n        address seller;\n        uint256 price;\n        uint256 duration;\n        uint256 maxBid;\n        address maxBidUser;\n        uint256 tokenId;\n        bool isActive;\n        uint256[] bidAmounts;\n        address[] users;\n    }\n\n    mapping(address => mapping(uint256 => AuctionInfo)) public tokenToAuction;\n\n    // Array with all token ids, used for enumeration\n    mapping(address => uint256[]) private _allTokenAuctions;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(address => mapping(uint256 => uint256))\n        private _allTokenAuctionsIndex;\n\n    mapping(address => mapping(uint256 => mapping(address => uint256)))\n        public bids;\n\n    function tokenAuctionSupply(address _nft) public view returns (uint256) {\n        return _allTokenAuctions[_nft].length;\n    }\n\n    function tokenAuctionIdByIndex(address _nft, uint256 index)\n        public\n        view\n        returns (uint256)\n    {\n        require(\n            index < tokenAuctionSupply(_nft),\n            \"ERC721Enumerable: global index out of bounds\"\n        );\n        return _allTokenAuctions[_nft][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenAuctionByIndex(address _nft, uint256 index)\n        public\n        view\n        returns (AuctionInfo memory)\n    {\n        uint256 tokenId = tokenAuctionIdByIndex(_nft, index);\n        return getTokenAuctionDetails(_nft, tokenId);\n    }\n\n    // function tokenAuctionIdByLength(\n    //     address _nft,\n    //     uint256 _start,\n    //     uint256 _length\n    // ) external view returns (uint256[] memory ids) {\n    //     require(_start < tokenAuctionSupply(_nft), \"Enumerable: global index out of bounds\");\n    //     ids = new uint256[](_length);\n    //     uint256 listingIndex;\n    //     for (uint256 index = _start; index < _start + _length; index++) {\n    //         if (tokenAuctionSupply(_nft) <= index) {\n    //           break;\n    //         }\n    //         ids[listingIndex] = tokenAuctionIdByIndex(_nft, index);\n    //         listingIndex++;\n    //     }\n    //     assembly {\n    //         mstore(ids, listingIndex)\n    //     }\n    // }\n\n    function tokenAuctionByLength(\n        address _nft,\n        uint256 _start,\n        uint256 _length\n    ) external view returns (AuctionInfo[] memory items) {\n        require(\n            _start < tokenAuctionSupply(_nft),\n            \"Enumerable: global index out of bounds\"\n        );\n        items = new AuctionInfo[](_length);\n        uint256 listingIndex;\n        for (uint256 index = _start; index < _start + _length; index++) {\n            if (tokenAuctionSupply(_nft) <= index) {\n                break;\n            }\n            items[listingIndex] = tokenAuctionByIndex(_nft, index);\n            listingIndex++;\n        }\n        assembly {\n            mstore(items, listingIndex)\n        }\n    }\n\n    function _addTokenToAllTokensEnumeration(address _nft, uint256 tokenId)\n        private\n    {\n        _allTokenAuctionsIndex[_nft][tokenId] = _allTokenAuctions[_nft].length;\n        _allTokenAuctions[_nft].push(tokenId);\n    }\n\n    function _removeTokenFromAllTokensEnumeration(address _nft, uint256 tokenId)\n        private\n    {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n        uint256 lastTokenAuctionIndex = _allTokenAuctions[_nft].length - 1;\n        uint256 tokenAuctionIndex = _allTokenAuctionsIndex[_nft][tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenAuctionId = _allTokenAuctions[_nft][\n            lastTokenAuctionIndex\n        ];\n\n        _allTokenAuctions[_nft][tokenAuctionIndex] = lastTokenAuctionId; // Move the last token to the slot of the to-delete token\n        _allTokenAuctionsIndex[_nft][lastTokenAuctionId] = tokenAuctionIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokenAuctionsIndex[_nft][tokenId];\n        _allTokenAuctions[_nft].pop();\n    }\n\n    /**\n       Seller puts the item on auction\n    */\n    function createTokenAuction(\n        address _nft,\n        uint256 _tokenId,\n        uint256 _price,\n        uint256 _duration\n    ) external {\n        require(msg.sender != address(0), \"Invalid Address\");\n        require(_nft != address(0), \"Invalid Account\");\n        require(_price > 0, \"Price should be more than 0\");\n        require(_duration > 0, \"Invalid duration value\");\n        AuctionInfo memory auctionInfo = AuctionInfo({\n            seller: msg.sender,\n            price: uint256(_price),\n            duration: _duration,\n            maxBid: 0,\n            maxBidUser: address(0),\n            isActive: true,\n            tokenId: _tokenId,\n            bidAmounts: new uint256[](0),\n            users: new address[](0)\n        });\n        address owner = msg.sender;\n        ERC721(_nft).safeTransferFrom(owner, address(this), _tokenId);\n        tokenToAuction[_nft][_tokenId] = auctionInfo;\n        _addTokenToAllTokensEnumeration(_nft, _tokenId);\n    }\n\n    /**\n       Users bid for a particular nft, the max bid is compared and set if the current bid id highest\n    */\n    function bid(address _nft, uint256 _tokenId) external payable {\n        AuctionInfo storage auctionInfo = tokenToAuction[_nft][_tokenId];\n        require(\n            msg.value >= auctionInfo.price,\n            \"bid price is less than current price\"\n        );\n        require(auctionInfo.isActive, \"auction not active\");\n        require(\n            auctionInfo.duration > block.timestamp,\n            \"Deadline already passed\"\n        );\n        if (bids[_nft][_tokenId][msg.sender] > 0) {\n            (bool success, ) = msg.sender.call{\n                value: bids[_nft][_tokenId][msg.sender]\n            }(\"\");\n            require(success);\n        }\n        bids[_nft][_tokenId][msg.sender] = msg.value;\n        if (auctionInfo.bidAmounts.length == 0) {\n            auctionInfo.maxBid = msg.value;\n            auctionInfo.maxBidUser = msg.sender;\n        } else {\n            uint256 lastIndex = auctionInfo.bidAmounts.length - 1;\n            require(\n                auctionInfo.bidAmounts[lastIndex] < msg.value,\n                \"Current max bid is higher than your bid\"\n            );\n            auctionInfo.maxBid = msg.value;\n            auctionInfo.maxBidUser = msg.sender;\n        }\n        auctionInfo.users.push(msg.sender);\n        auctionInfo.bidAmounts.push(msg.value);\n    }\n\n    /**\n       Called by the seller when the auction duration is over the hightest bid user get's the nft and other bidders get eth back\n    */\n    function executeSale(address _nft, uint256 _tokenId) external {\n        AuctionInfo storage auctionInfo = tokenToAuction[_nft][_tokenId];\n        require(\n            auctionInfo.duration <= block.timestamp,\n            \"Deadline did not pass yet\"\n        );\n        require(auctionInfo.seller == msg.sender, \"Not seller\");\n        require(auctionInfo.isActive, \"auction not active\");\n        auctionInfo.isActive = false;\n        if (auctionInfo.bidAmounts.length == 0) {\n            ERC721(_nft).safeTransferFrom(\n                address(this),\n                auctionInfo.seller,\n                _tokenId\n            );\n        } else {\n            (bool success, ) = auctionInfo.seller.call{\n                value: auctionInfo.maxBid\n            }(\"\");\n            require(success);\n            for (uint256 i = 0; i < auctionInfo.users.length; i++) {\n                address user = auctionInfo.users[i];\n                if (\n                    user != auctionInfo.maxBidUser &&\n                    bids[_nft][_tokenId][user] > 0\n                ) {\n                    (success, ) = user.call{value: bids[_nft][_tokenId][user]}(\n                        \"\"\n                    );\n                    require(success);\n                    bids[_nft][_tokenId][user] = 0;\n                }\n            }\n            ERC721(_nft).safeTransferFrom(\n                address(this),\n                auctionInfo.maxBidUser,\n                _tokenId\n            );\n        }\n        _removeTokenFromAllTokensEnumeration(_nft, _tokenId);\n    }\n\n    /**\n       Called by the seller if they want to cancel the auction for their nft so the bidders get back the locked eeth and the seller get's back the nft\n    */\n    function cancelAuction(address _nft, uint256 _tokenId) external {\n        AuctionInfo storage auctionInfo = tokenToAuction[_nft][_tokenId];\n        require(auctionInfo.seller == msg.sender, \"Not seller\");\n        require(auctionInfo.isActive, \"auction not active\");\n        auctionInfo.isActive = false;\n        bool success;\n        for (uint256 i = 0; i < auctionInfo.users.length; i++) {\n            address user = auctionInfo.users[i];\n            if (bids[_nft][_tokenId][user] > 0) {\n                (success, ) = user.call{value: bids[_nft][_tokenId][user]}(\"\");\n                require(success);\n                bids[_nft][_tokenId][user] = 0;\n            }\n        }\n        ERC721(_nft).safeTransferFrom(\n            address(this),\n            auctionInfo.seller,\n            _tokenId\n        );\n        _removeTokenFromAllTokensEnumeration(_nft, _tokenId);\n    }\n\n    function getTokenAuctionDetails(address _nft, uint256 _tokenId)\n        public\n        view\n        returns (AuctionInfo memory)\n    {\n        AuctionInfo memory auctionInfo = tokenToAuction[_nft][_tokenId];\n        return auctionInfo;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return\n            bytes4(\n                keccak256(\"onERC721Received(address,address,uint256,bytes)\")\n            );\n    }\n\n    receive() external payable {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}