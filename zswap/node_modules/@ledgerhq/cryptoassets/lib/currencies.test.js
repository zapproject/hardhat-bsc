"use strict";

var _fiats = require("./fiats");

var _tokens = require("./tokens");

var _currencies = require("./currencies");

test("can get currency by coin type", () => {
  expect((0, _currencies.getCryptoCurrencyById)("bitcoin")).toMatchObject({
    id: "bitcoin",
    name: "Bitcoin"
  });
  expect((0, _currencies.getCryptoCurrencyById)("litecoin")).toMatchObject({
    id: "litecoin",
    name: "Litecoin"
  });
  expect((0, _currencies.hasCryptoCurrencyId)("bitcoin")).toBe(true);
  expect((0, _currencies.hasCryptoCurrencyId)("")).toBe(false);
  expect(() => (0, _currencies.getCryptoCurrencyById)("")).toThrow();
  expect((0, _currencies.hasCryptoCurrencyId)("_")).toBe(false);
  expect(() => (0, _currencies.getCryptoCurrencyById)("_")).toThrow();
});
test("can find currency", () => {
  const bitcoinMatch = {
    id: "bitcoin",
    name: "Bitcoin"
  };
  expect((0, _currencies.findCryptoCurrency)(c => c.name === "Bitcoin")).toMatchObject(bitcoinMatch);
  expect((0, _currencies.findCryptoCurrencyById)("bitcoin")).toMatchObject(bitcoinMatch);
  expect((0, _currencies.findCryptoCurrencyByKeyword)("btc")).toMatchObject(bitcoinMatch);
  expect((0, _currencies.findCryptoCurrencyByKeyword)("btc")).toMatchObject(bitcoinMatch);
  expect((0, _currencies.findCryptoCurrencyByKeyword)("btc")).toMatchObject(bitcoinMatch);
  expect((0, _currencies.findCryptoCurrencyByTicker)("BTC")).toMatchObject(bitcoinMatch);
  expect((0, _currencies.findCryptoCurrencyByScheme)("bitcoin")).toMatchObject(bitcoinMatch);
  expect((0, _currencies.findCryptoCurrencyById)("_")).toBe(undefined);
  expect((0, _currencies.findCryptoCurrencyByKeyword)("_")).toBe(undefined);
  expect((0, _currencies.findCryptoCurrencyByKeyword)("_")).toBe(undefined);
  expect((0, _currencies.findCryptoCurrencyByKeyword)("_")).toBe(undefined);
  expect((0, _currencies.findCryptoCurrencyByTicker)("_")).toBe(undefined);
  expect((0, _currencies.findCryptoCurrencyByScheme)("_")).toBe(undefined);
});
test("there are some dev cryptocurrencies", () => {
  const all = (0, _currencies.listCryptoCurrencies)(true);
  const prod = (0, _currencies.listCryptoCurrencies)();
  expect(all).not.toBe(prod);
  expect(all.filter(a => !a.isTestnetFor)).toMatchObject(prod);
  expect(all.length).toBeGreaterThan(prod.length);
});
test("there are some terminated cryptocurrencies", () => {
  const all = (0, _currencies.listCryptoCurrencies)(false, true);
  const supported = (0, _currencies.listCryptoCurrencies)();
  expect(all).not.toBe(supported);
  expect(all.filter(a => !a.terminated)).toMatchObject(supported);
  expect(all.length).toBeGreaterThan(supported.length);
});
test("all cryptocurrencies match (by reference) the one you get by id", () => {
  for (let c of (0, _currencies.listCryptoCurrencies)()) {
    expect(c).toBe((0, _currencies.getCryptoCurrencyById)(c.id));
  }
});
test("there is no testnet or terminated coin by default", () => {
  expect((0, _currencies.listCryptoCurrencies)(false, false)).toBe((0, _currencies.listCryptoCurrencies)());
  expect((0, _currencies.listCryptoCurrencies)(true, true).length).toBeGreaterThan((0, _currencies.listCryptoCurrencies)().length);

  for (let c of (0, _currencies.listCryptoCurrencies)()) {
    expect(!c.terminated).toBe(true);
    expect(!c.isTestnetFor).toBe(true);
  }
});
test("all cryptocurrencies have at least one unit", () => {
  for (let c of (0, _currencies.listCryptoCurrencies)()) {
    expect(c.units.length).toBeGreaterThan(0);
  }
});
test("fiats list is always the same", () => {
  expect((0, _fiats.listFiatCurrencies)()).toEqual((0, _fiats.listFiatCurrencies)());
});
test("fiats list elements are correct", () => {
  const tickers = {};

  for (const fiat of (0, _fiats.listFiatCurrencies)()) {
    expect(fiat.ticker).toBeTruthy();
    expect(typeof fiat.ticker).toBe("string");
    expect(tickers[fiat.ticker]).toBeFalsy();
    expect(fiat.units.length).toBeGreaterThan(0);
    const unit = fiat.units[0];
    expect(unit.code).toBeTruthy();
    expect(typeof unit.code).toBe("string");
    expect(unit.name).toBeTruthy();
    expect(typeof unit.name).toBe("string");
    expect(unit.magnitude).toBeGreaterThan(-1);
    expect(typeof unit.magnitude).toBe("number");
    tickers[fiat.ticker] = unit;
  }
});
test("tokens are correct", () => {
  expect((0, _tokens.listTokens)().length).toBeGreaterThan(0);

  for (const token of (0, _tokens.listTokens)()) {
    expect(token.ticker).toBeTruthy();
    expect(typeof token.id).toBe("string");
    expect(typeof token.name).toBe("string");

    if (token.ledgerSignature) {
      expect(typeof token.ledgerSignature).toBe("string");
    }

    expect(typeof token.tokenType).toBe("string");
    expect(typeof token.parentCurrency).toBe("object");
    expect((0, _currencies.hasCryptoCurrencyId)(token.parentCurrency.id)).toBe(true);
    expect(typeof token.ticker).toBe("string");
    expect(token.units.length).toBeGreaterThan(0);
    const unit = token.units[0];
    expect(unit.code).toBeTruthy();
    expect(typeof unit.code).toBe("string");
    expect(unit.name).toBeTruthy();
    expect(typeof unit.name).toBe("string");
    expect(unit.magnitude).toBeGreaterThan(-1);
    expect(typeof unit.magnitude).toBe("number");

    if (token.compoundFor) {
      const t = (0, _tokens.findTokenById)(token.compoundFor);
      expect(typeof t).toBe("object");
    }
  }
});
test("fiats list is sorted by ticker", () => {
  expect((0, _fiats.listFiatCurrencies)().map(fiat => fiat.ticker).join(",")).toEqual((0, _fiats.listFiatCurrencies)().map(fiat => fiat.ticker).sort((a, b) => a > b ? 1 : -1).join(","));
});
test("can get fiat by coin type", () => {
  expect((0, _fiats.getFiatCurrencyByTicker)("USD").units[0]).toMatchObject({
    magnitude: 2
  });
  expect((0, _fiats.getFiatCurrencyByTicker)("EUR").units[0]).toMatchObject({
    magnitude: 2
  }); // this is not a fiat \o/

  expect(() => (0, _fiats.getFiatCurrencyByTicker)("USDT").units[0]).toThrow();
  expect((0, _fiats.hasFiatCurrencyTicker)("USD")).toBe(true);
  expect((0, _fiats.hasFiatCurrencyTicker)("USDT")).toBe(false);
});
test("all USDT are countervalue enabled", () => {
  const tokens = (0, _tokens.listTokens)().filter(t => t.ticker === "USDT" && !t.parentCurrency.isTestnetFor);
  expect(tokens.map(t => t.id).sort()).toMatchSnapshot();
  expect(tokens.every(t => t.disableCountervalue === false)).toBe(true);
});
test("can register a new coin externally", () => {
  const coinId = "mycoin";
  expect(() => (0, _currencies.getCryptoCurrencyById)("mycoin")).toThrow(`currency with id "${coinId}" not found`);
  const mycoin = {
    type: "CryptoCurrency",
    id: coinId,
    coinType: 8008,
    name: "MyCoin",
    managerAppName: "MyCoin",
    ticker: "MYC",
    countervalueTicker: "MYC",
    scheme: "mycoin",
    color: "#ff0000",
    family: "mycoin",
    units: [{
      name: "MYC",
      code: "MYC",
      magnitude: 8
    }, {
      name: "SmallestUnit",
      code: "SMALLESTUNIT",
      magnitude: 0
    }],
    explorerViews: [{
      address: "https://mycoinexplorer.com/account/$address",
      tx: "https://mycoinexplorer.com/transaction/$hash",
      token: "https://mycoinexplorer.com/token/$contractAddress/?a=$address"
    }]
  };
  (0, _currencies.registerCryptoCurrency)(coinId, mycoin);
  expect((0, _currencies.getCryptoCurrencyById)(coinId)).toEqual(mycoin);
});
//# sourceMappingURL=currencies.test.js.map