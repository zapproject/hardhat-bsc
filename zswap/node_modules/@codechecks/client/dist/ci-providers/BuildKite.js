"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../utils/errors");
function parseRepositorySlug(repoUrl) {
    const GIT_URL_REGEX = /^(https|git)(:\/\/|@)([^\/:]+)[\/:]([^\/:]+)\/(.+).git$/;
    const repoMatch = repoUrl.match(GIT_URL_REGEX);
    if (!repoMatch) {
        throw errors_1.crash(`Couldnt parse repository slug from ${repoUrl}`);
    }
    return `${repoMatch[4]}/${repoMatch[5]}`;
}
exports.parseRepositorySlug = parseRepositorySlug;
class BuildKite {
    constructor(env) {
        this.env = env;
    }
    isCurrentlyRunning() {
        return this.env["BUILDKITE"] === "true";
    }
    getPullRequestID() {
        const prNumberRaw = this.env["BUILDKITE_PULL_REQUEST"] || "false";
        if (prNumberRaw === "false") {
            return undefined;
        }
        return parseInt(prNumberRaw);
    }
    getCurrentSha() {
        const sha = this.env["BUILDKITE_COMMIT"];
        if (!sha) {
            throw errors_1.crash("Couldnt get target SHA");
        }
        return sha;
    }
    isFork() {
        if (this.env["BUILDKITE_PULL_REQUEST"] === "false") {
            return false;
        }
        const buildKitePullRequestRepo = this.env["BUILDKITE_PULL_REQUEST_REPO"] || "";
        const buildKiteRepo = this.env["BUILDKITE_REPO"] || "";
        try {
            const prSlug = parseRepositorySlug(buildKitePullRequestRepo);
            const repoSlug = parseRepositorySlug(buildKiteRepo);
            return prSlug !== repoSlug;
        }
        catch (_a) {
            return false;
        }
    }
    getProjectSlug() {
        const buildKiteRepo = this.env["BUILDKITE_REPO"] || "";
        return parseRepositorySlug(buildKiteRepo);
    }
    supportsSpeculativeBranchSelection() {
        return true;
    }
}
exports.BuildKite = BuildKite;
//# sourceMappingURL=BuildKite.js.map