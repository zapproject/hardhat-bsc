#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("./utils/hijackModuleLoading");
const util_1 = require("util");
const program = require("commander");
const ms = require("ms");
const ci_providers_1 = require("./ci-providers");
const getExecutionContext_1 = require("./getExecutionContext");
const api_1 = require("./api");
const client_1 = require("./client");
const utils_1 = require("./utils");
const execution_1 = require("./file-executors/execution");
const _1 = require(".");
const Local_1 = require("./ci-providers/Local");
const logger_1 = require("./logger");
const settings_1 = require("./file-handling/settings");
const git_1 = require("./utils/git");
const errors_1 = require("./utils/errors");
const getRunnerConfig_1 = require("./getRunnerConfig");
async function main(args, codecheckFiles = execution_1.findCodechecksFiles(process.cwd())) {
    const { project } = args;
    logger_1.printLogo();
    logger_1.logger.log(`Executing ${logger_1.bold(codecheckFiles.length)} codechecks files`);
    const startTime = new Date().getTime();
    const provider = ci_providers_1.findProvider(process.env, project);
    const requiresSecret = Local_1.checkIfIsLocalMode(provider) || (await provider.isFork());
    const api = new api_1.Api(api_1.getApiOptions(requiresSecret));
    if (provider.setApi) {
        provider.setApi(api);
    }
    const gitRoot = git_1.findRootGitRepository(process.cwd());
    if (!gitRoot) {
        throw errors_1.crash("Couldn't find git project root!");
    }
    const settings = await settings_1.loadCodechecksSettings(gitRoot);
    const sharedExecutionCtx = await getExecutionContext_1.getConstExecutionContext(api, provider, settings, gitRoot, args);
    logger_1.logger.debug({ sharedExecutionCtx });
    api.sharedCtx = sharedExecutionCtx;
    if (sharedExecutionCtx.isFork) {
        logger_1.logger.log("Running for fork!");
    }
    if (sharedExecutionCtx.isLocalMode) {
        logger_1.logger.log("Running in local mode!");
    }
    if (sharedExecutionCtx.isPr) {
        logger_1.logger.log(`Base branch: ${logger_1.bold(logger_1.formatSHA(sharedExecutionCtx.pr.base.sha))}`);
    }
    console.log();
    const runnerConfig = getRunnerConfig_1.getRunnerConfig(args);
    let successCodechecks = 0;
    let failureCodechecks = 0;
    for (const codecheckFile of codecheckFiles) {
        logger_1.logger.log(`Executing ${logger_1.bold(logger_1.formatPath(codecheckFile, gitRoot))}...`);
        logger_1.logger.log();
        // do not use this instance after clone
        const fileExecutionCtx = getExecutionContext_1.getExecutionContext(sharedExecutionCtx, codecheckFile);
        logger_1.logger.debug({ fileExecutionCtx });
        const _client = new client_1.CodechecksClient(api, fileExecutionCtx);
        replaceObject(_1.codechecks, _client);
        global.__codechecks_client = _client;
        await execution_1.executeCodechecksFile(codecheckFile);
        successCodechecks += _client.countSuccesses();
        failureCodechecks += _client.countFailures();
    }
    const finishTime = new Date().getTime();
    const deltaTime = finishTime - startTime;
    const result = [
        failureCodechecks > 0 ? logger_1.bold(logger_1.red(`${failureCodechecks} failed`)) : false,
        successCodechecks > 0 ? logger_1.bold(logger_1.green(`${successCodechecks} succeeded`)) : false,
        `${failureCodechecks + successCodechecks} total`,
    ]
        .filter(Boolean)
        .join(", ");
    logger_1.logger.log(`${logger_1.bold("Checks:")} ${result}`);
    logger_1.logger.log(`${logger_1.bold("Time:")}   ${ms(deltaTime)}`);
    if (runnerConfig.isWithExitStatus && failureCodechecks > 0) {
        process.exit(1);
    }
}
const command = program
    .version(require("../package.json").version)
    .option("-p, --project [projectSlug]", "Project slug, works only in local mode")
    .option("--fail-fast", "Stops running checks after the first failure, works only in local mode")
    .option("-x, --with-exit-status", "Exits the process with exit status according to checks result")
    .usage("codechecks [codechecks.yml|json|ts|js]")
    .parse(process.argv);
const args = {
    project: command.project,
    failFast: command.failFast,
    withExitStatus: command.withExitStatus,
};
main(args, command.args.length > 0 ? command.args.map(a => utils_1.normalizePath(a)) : undefined).catch(e => {
    // we want informative output but we don't want leaking secrets into any logs
    if (errors_1.isCodeChecksCrash(e)) {
        logger_1.logger.error(utils_1.maskSecrets(e.message, process.env));
        logger_1.logger.debug(utils_1.maskSecrets(util_1.inspect(e), process.env));
    }
    else {
        logger_1.logger.log(utils_1.maskSecrets(util_1.inspect(e), process.env));
    }
    process.exit(1);
});
// @todo is there a way to avoid doing prototype shenanigans also without polluting index.js by introducing something like __setClient?
function replaceObject(old, newObject) {
    Object.assign(old, newObject);
    old.__proto__ = newObject.__proto__;
}
//# sourceMappingURL=runner.js.map