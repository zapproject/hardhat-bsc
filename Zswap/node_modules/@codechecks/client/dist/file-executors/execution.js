"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_1 = require("fs");
const tsExecutor_1 = require("./tsExecutor");
const jsExecutor_1 = require("./jsExecutor");
const executeJson_1 = require("./executeJson");
const executeYaml_1 = require("./executeYaml");
const errors_1 = require("../utils/errors");
const CODECHECKS_FILES_NAMES = [
    "codechecks.yml",
    "codechecks.yaml",
    "codechecks.json",
    "codechecks.ts",
    "codechecks.js",
];
async function executeCodechecksFile(codeChecksFilePath, options) {
    const extension = path_1.extname(codeChecksFilePath).slice(1);
    switch (extension) {
        case "ts":
            return await tsExecutor_1.executeTs(codeChecksFilePath, options);
        case "js":
        case "": // requiring a module
            return await jsExecutor_1.executeJs(codeChecksFilePath, options);
        case "json":
            return await executeJson_1.executeCodechecksJson(codeChecksFilePath);
        case "yml":
        case "yaml":
            return await executeYaml_1.executeCodechecksYaml(codeChecksFilePath);
        default:
            throw errors_1.crash(`Unsupported file extension ${extension}`);
    }
}
exports.executeCodechecksFile = executeCodechecksFile;
function findCodechecksFiles(basePath) {
    const existingFiles = CODECHECKS_FILES_NAMES.map(n => path_1.join(basePath, n)).filter(filePath => {
        return fs_1.existsSync(filePath);
    });
    if (existingFiles.length === 0) {
        throw errors_1.crash(`Couldnt find CodeChecks files. Checked path: ${basePath}`);
    }
    return existingFiles;
}
exports.findCodechecksFiles = findCodechecksFiles;
//# sourceMappingURL=execution.js.map