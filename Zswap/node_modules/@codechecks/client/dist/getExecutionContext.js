"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const Local_1 = require("./ci-providers/Local");
const speculativeBranchSelection_1 = require("./speculativeBranchSelection");
const errors_1 = require("./utils/errors");
/**
 * Better part of execution context stays the same for all codechecks files being executed so we just get it once.
 */
async function getConstExecutionContext(api, ciProvider, settings, gitRepoRootPath, args) {
    const currentSha = await ciProvider.getCurrentSha();
    const isFork = await ciProvider.isFork();
    const pr = await ciProvider.getPullRequestID();
    const projectSlug = await ciProvider.getProjectSlug();
    if (!pr && isFork) {
        throw errors_1.crash("Provider should never be in fork mode and not in PR mode!");
    }
    let prInfo;
    let projectInfo;
    let localMode;
    let isSpeculativePr = false;
    if (ciProvider instanceof Local_1.LocalProvider) {
        let isOffline = false;
        try {
            projectInfo = await api.projectInfoPublic(projectSlug);
        }
        catch (_a) {
            isOffline = true;
            projectInfo = {
                projectSlug: "local/project",
                artifactsProxyUrl: "http://nowhere",
                artifactsProxySupportsPages: true,
                isPrivate: false,
            };
        }
        localMode = {
            projectSlug,
            isOffline,
            isFailFast: !!args.failFast,
        };
        prInfo = await ciProvider.getPrInfo();
    }
    else if (isFork) {
        projectInfo = await api.projectInfoPublic(projectSlug);
        if (pr !== undefined) {
            prInfo = await api.prInfoPublic(pr, projectSlug);
        }
    }
    else {
        projectInfo = await api.projectInfo();
        if (pr !== undefined || settings.speculativeBranchSelection) {
            if (pr) {
                prInfo = await api.prInfo(pr);
            }
            else if (ciProvider.supportsSpeculativeBranchSelection()) {
                prInfo = await speculativeBranchSelection_1.getPrInfoForSpeculativeBranch(settings, gitRepoRootPath);
                if (prInfo) {
                    isSpeculativePr = true;
                }
            }
        }
    }
    if (prInfo !== undefined) {
        return {
            isPr: true,
            isPrivate: projectInfo.isPrivate,
            projectSlug: projectInfo.projectSlug,
            artifactsProxy: {
                url: projectInfo.artifactsProxyUrl,
                supportsPages: projectInfo.artifactsProxySupportsPages,
            },
            currentSha,
            isLocalMode: localMode,
            pr: prInfo,
            isFork,
            isSpeculativePr,
        };
    }
    else {
        return {
            isPr: false,
            isPrivate: projectInfo.isPrivate,
            projectSlug: projectInfo.projectSlug,
            artifactsProxy: {
                url: projectInfo.artifactsProxyUrl,
                supportsPages: projectInfo.artifactsProxySupportsPages,
            },
            currentSha,
            isLocalMode: localMode,
            isFork,
            isSpeculativePr: false,
        };
    }
}
exports.getConstExecutionContext = getConstExecutionContext;
function getExecutionContext(sharedExecutionCtx, codeChecksFilePath) {
    return Object.assign({ codeChecksFileAbsPath: codeChecksFilePath, workspaceRoot: path_1.dirname(codeChecksFilePath) }, sharedExecutionCtx);
}
exports.getExecutionContext = getExecutionContext;
//# sourceMappingURL=getExecutionContext.js.map