"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../utils/errors");
class Circle {
    constructor(env) {
        this.env = env;
    }
    isCurrentlyRunning() {
        return this.env["CIRCLECI"] === "true";
    }
    getPullRequestID() {
        const prLink = this.env["CIRCLE_PULL_REQUEST"] || "";
        // get everything before last slash
        const parts = prLink.split("/");
        const prNumberRaw = parts[parts.length - 1];
        const prNumber = parseInt(prNumberRaw);
        if (isNaN(prNumber)) {
            return undefined;
        }
        return prNumber;
    }
    getCurrentSha() {
        const sha = this.env["CIRCLE_SHA1"];
        if (!sha) {
            throw errors_1.crash("Couldnt get target SHA");
        }
        return sha;
    }
    isFork() {
        if (!this.env["CIRCLE_PULL_REQUESTS"]) {
            return false;
        }
        // i think these exist only when fork is executed on original owners CI
        if (!!this.env.CIRCLE_PR_USERNAME && !!this.env.CIRCLE_PR_REPONAME) {
            return true;
        }
        const projectSlugFromPrList = this.getPrInfoFromPrList();
        const projectSlugFromBuildURL = this.getPrInfoFromBuildURL();
        return projectSlugFromPrList.user !== projectSlugFromBuildURL.user;
    }
    getProjectSlug() {
        const prInfo = this.isFork() ? this.getPrInfoFromPrList() : this.getPrInfoFromBuildURL();
        return `${prInfo.user}/${prInfo.projectName}`;
    }
    getPrInfoFromPrList() {
        const prs = this.getPullRequests();
        const pr = prs[0]; // always just take first valid PR... at least for now @todo
        const prInfo = parsePrUrl(pr);
        if (!prInfo) {
            throw errors_1.crash(`Couldnt parse PR url: ${pr}`);
        }
        return prInfo;
    }
    getPrInfoFromBuildURL() {
        const buildUrl = this.env["CIRCLE_BUILD_URL"];
        if (!buildUrl) {
            throw errors_1.crash("CIRCLE_BUILD_URL is missing!");
        }
        const prInfo = parseBuildURL(buildUrl);
        if (!prInfo) {
            throw errors_1.crash(`Couldnt parse CIRCLE_BUILD_URL: ${buildUrl}`);
        }
        return prInfo;
    }
    getPullRequests() {
        const prs = this.env["CIRCLE_PULL_REQUESTS"];
        if (!prs) {
            throw errors_1.crash("Missing CIRCLE_PULL_REQUESTS");
        }
        return prs.split(",");
    }
    supportsSpeculativeBranchSelection() {
        return true;
    }
}
exports.Circle = Circle;
function parseBuildURL(buildUrl) {
    if (!buildUrl) {
        return;
    }
    //parse for example: https://circleci.com/gh/BrunnerLivio/nest/58
    const regex = /https:\/\/circleci\.com\/gh\/(.*?)\/(.*?)\/([0-9]*)/;
    const match = buildUrl.match(regex);
    if (!match) {
        return;
    }
    const [, user, projectName, buildId] = match;
    return {
        user,
        projectName,
        id: parseInt(buildId),
    };
}
function parsePrUrl(prUrl) {
    if (!prUrl) {
        return;
    }
    // parse for example: https://github.com/nestjs/nest/pull/2888
    const PROJECT_SLUG_REGEX = /https:\/\/github\.com\/(.*?)\/(.*?)\/([0-9]*)/;
    const match = prUrl.match(PROJECT_SLUG_REGEX);
    if (!match) {
        return;
    }
    const [, user, projectName, buildId] = match;
    return { user, projectName, id: parseInt(buildId) };
}
//# sourceMappingURL=Circle.js.map