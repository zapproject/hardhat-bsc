"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const execa = require("execa");
const marked = require("marked");
const TerminalRenderer = require("marked-terminal");
const logger_1 = require("../logger");
const git_1 = require("../utils/git");
/**
 * Run codechecks locally, not on CI. It requires running within git reposistory.
 */
class LocalProvider {
    constructor(env, forcedLocalProjectSlug) {
        this.env = env;
        this.forcedLocalProjectSlug = forcedLocalProjectSlug;
    }
    isCurrentlyRunning() {
        // additionally local CI provider will be ignored if any other CI is detected. It's done like this because it's hard to detect if we ran inside ANY CI.
        // ex. GithubActions doesnt set CI = true
        const isCI = this.env["CI"];
        return !isCI;
    }
    async getCurrentSha() {
        return await this.getShaForRef("HEAD");
    }
    async getProjectSlug() {
        // allow users to override local project slug
        if (this.forcedLocalProjectSlug) {
            return this.forcedLocalProjectSlug;
        }
        const rawRemoteUrl = (await execa.shell("git config --get remote.origin.url")).stdout.trim();
        return git_1.fullNameFromRemoteUrl(rawRemoteUrl);
    }
    getPullRequestID() {
        return 0;
    }
    async getPrInfo() {
        return {
            id: 0,
            meta: {
                title: "Local run",
                body: "local run",
            },
            // @todo implement those. It's possible to get it from git
            files: {
                added: [],
                changed: [],
                removed: [],
            },
            head: {
                sha: await this.getCurrentSha(),
            },
            base: {
                sha: await this.getShaForRef((await execa.shell(`git symbolic-ref --short HEAD`)).stdout.trim()),
            },
        };
    }
    async getShaForRef(ref) {
        return (await execa.shell(`git rev-parse ${ref}`)).stdout.trim();
    }
    isFork() {
        return false;
    }
    supportsSpeculativeBranchSelection() {
        return true;
    }
}
exports.LocalProvider = LocalProvider;
function checkIfIsLocalMode(provider) {
    return provider instanceof LocalProvider;
}
exports.checkIfIsLocalMode = checkIfIsLocalMode;
marked.setOptions({
    // Define custom renderer
    renderer: new TerminalRenderer(),
});
function printCheck(report) {
    logger_1.logger.log(marked(`
# ${report.status === "success" ? "✅" : "❌"} ${report.name}
${report.shortDescription}`));
    if (report.longDescription) {
        logger_1.logger.log(marked(`
## Long description:
${report.longDescription}`));
    }
    logger_1.logger.log(chalk_1.default.dim("---------------"));
    logger_1.logger.log();
}
function processReport(report, context) {
    printCheck(report);
    const isFailure = report.status === "failure";
    const { isLocalMode } = context;
    const shouldInterrupt = isFailure && isLocalMode && isLocalMode.isFailFast;
    if (shouldInterrupt) {
        logger_1.logger.critical(`"${report.name}" check failed in fail fast mode`);
    }
}
exports.processReport = processReport;
//# sourceMappingURL=Local.js.map