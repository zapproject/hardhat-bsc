{"version":3,"sources":["../src/TransportNodeHid.js"],"names":["HID","Transport","log","ledgerUSBVendorId","hidFraming","identifyUSBProductId","identifyProductName","TransportError","DisconnectedDevice","filterInterface","device","includes","process","platform","usagePage","interface","getDevices","devices","filter","isDisconnectedError","e","message","indexOf","TransportNodeHidNoEvents","open","path","Promise","resolve","then","constructor","deviceModel","channel","Math","floor","random","packetSize","disconnected","setDisconnected","emit","writeHID","content","data","i","length","push","write","reject","readHID","read","res","buffer","Buffer","from","exchange","apdu","exchangeAtomicImpl","toString","framing","blocks","makeBlocks","result","acc","getReducedResult","reduceResponse","info","getDeviceInfo","product","setScrambleKey","close","exchangeBusyPromise","isSupported","list","map","d","listen","observer","forEach","productId","next","type","descriptor","complete","unsubscribe"],"mappings":"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","sourcesContent":["//@flow\n\nimport HID from \"node-hid\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { log } from \"@ledgerhq/logs\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport { ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId, identifyProductName } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { TransportError, DisconnectedDevice } from \"@ledgerhq/errors\";\n\nconst filterInterface = (device) =>\n  [\"win32\", \"darwin\"].includes(process.platform)\n    ? // $FlowFixMe\n      device.usagePage === 0xffa0\n    : device.interface === 0;\n\nexport function getDevices(): Array<*> {\n  // $FlowFixMe\n  return HID.devices(ledgerUSBVendorId, 0x0).filter(filterInterface);\n}\n\nconst isDisconnectedError = (e) =>\n  e && e.message && e.message.indexOf(\"HID\") >= 0;\n\n/**\n * node-hid Transport minimal implementation\n * @example\n * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid-noevents\";\n * ...\n * TransportNodeHid.create().then(transport => ...)\n */\nexport default class TransportNodeHidNoEvents extends Transport<?string> {\n  /**\n   *\n   */\n  static isSupported = (): Promise<boolean> =>\n    Promise.resolve(typeof HID.HID === \"function\");\n\n  /**\n   *\n   */\n  static list = (): Promise<(?string)[]> =>\n    Promise.resolve(getDevices().map((d) => d.path));\n\n  /**\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<?string>>\n  ): Subscription => {\n    getDevices().forEach((device) => {\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device.path,\n        deviceModel,\n        device,\n      });\n    });\n    observer.complete();\n    return { unsubscribe: () => {} };\n  };\n\n  /**\n   * if path=\"\" is not provided, the library will take the first device\n   */\n  static open(path: ?string) {\n    return Promise.resolve().then(() => {\n      if (path) {\n        return new TransportNodeHidNoEvents(new HID.HID(path));\n      }\n      const device = getDevices()[0];\n      if (!device) throw new TransportError(\"NoDevice\", \"NoDevice\");\n      return new TransportNodeHidNoEvents(new HID.HID(device.path));\n    });\n  }\n\n  device: HID.HID;\n  deviceModel: ?DeviceModel;\n\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n  disconnected = false;\n\n  constructor(device: HID.HID) {\n    super();\n    this.device = device;\n    // $FlowFixMe\n    const info = device.getDeviceInfo();\n    this.deviceModel =\n      info && info.product ? identifyProductName(info.product) : null;\n  }\n\n  setDisconnected = () => {\n    if (!this.disconnected) {\n      this.emit(\"disconnect\");\n      this.disconnected = true;\n    }\n  };\n\n  writeHID = (content: Buffer): Promise<void> => {\n    const data = [0x00];\n    for (let i = 0; i < content.length; i++) {\n      data.push(content[i]);\n    }\n    try {\n      this.device.write(data);\n      return Promise.resolve();\n    } catch (e) {\n      if (isDisconnectedError(e)) {\n        this.setDisconnected();\n        return Promise.reject(new DisconnectedDevice(e.message));\n      }\n      return Promise.reject(e);\n    }\n  };\n\n  readHID = (): Promise<Buffer> =>\n    new Promise((resolve, reject) =>\n      this.device.read((e, res) => {\n        if (!res) {\n          return reject(new DisconnectedDevice());\n        }\n        if (e) {\n          if (isDisconnectedError(e)) {\n            this.setDisconnected();\n            return reject(new DisconnectedDevice(e.message));\n          }\n          reject(e);\n        } else {\n          const buffer = Buffer.from(res);\n          resolve(buffer);\n        }\n      })\n    );\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.writeHID(blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const buffer = await this.readHID();\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    });\n\n  setScrambleKey() {}\n\n  /**\n   * release the USB device.\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    this.device.close();\n  }\n}\n"],"file":"TransportNodeHid.js"}