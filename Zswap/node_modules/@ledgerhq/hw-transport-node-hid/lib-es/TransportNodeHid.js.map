{"version":3,"sources":["../src/TransportNodeHid.js"],"names":["HID","TransportNodeHidNoEvents","getDevices","identifyUSBProductId","TransportError","listenDevices","listenDevicesDebounce","listenDevicesPollingSkip","TransportNodeHid","open","path","Promise","resolve","then","device","isSupported","list","setListenDevicesDebounce","delay","setListenDevicesPollingSkip","conditionToSkip","setListenDevicesDebug","console","warn","listen","observer","unsubscribed","devices","descriptor","deviceModel","productId","next","type","events","stop","onAdd","onRemove","on","unsubscribe","removeListener"],"mappings":"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","sourcesContent":["//@flow\n\nimport HID from \"node-hid\";\nimport TransportNodeHidNoEvents, {\n  getDevices,\n} from \"@ledgerhq/hw-transport-node-hid-noevents\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport { TransportError } from \"@ledgerhq/errors\";\nimport listenDevices from \"./listenDevices\";\n\nlet listenDevicesDebounce = 500;\nlet listenDevicesPollingSkip = () => false;\n\n/**\n * node-hid Transport implementation\n * @example\n * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid\";\n * ...\n * TransportNodeHid.create().then(transport => ...)\n */\nexport default class TransportNodeHid extends TransportNodeHidNoEvents {\n  /**\n   *\n   */\n  static isSupported = TransportNodeHidNoEvents.isSupported;\n\n  /**\n   *\n   */\n  static list = TransportNodeHidNoEvents.list;\n\n  /**\n   *\n   */\n  static setListenDevicesDebounce = (delay: number) => {\n    listenDevicesDebounce = delay;\n  };\n\n  /**\n   *\n   */\n  static setListenDevicesPollingSkip = (conditionToSkip: () => boolean) => {\n    listenDevicesPollingSkip = conditionToSkip;\n  };\n\n  /**\n   *\n   */\n  static setListenDevicesDebug = () => {\n    console.warn(\n      \"setListenDevicesDebug is deprecated. Use @ledgerhq/logs instead. No logs will get emitted there anymore.\"\n    );\n  };\n\n  /**\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<?string>>\n  ): Subscription => {\n    let unsubscribed = false;\n    Promise.resolve(getDevices()).then((devices) => {\n      // this needs to run asynchronously so the subscription is defined during this phase\n      for (const device of devices) {\n        if (!unsubscribed) {\n          const descriptor: string = device.path;\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor, device, deviceModel });\n        }\n      }\n    });\n    const { events, stop } = listenDevices(\n      listenDevicesDebounce,\n      listenDevicesPollingSkip\n    );\n\n    const onAdd = (device) => {\n      if (unsubscribed || !device) return;\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device.path,\n        deviceModel,\n        device,\n      });\n    };\n    const onRemove = (device) => {\n      if (unsubscribed || !device) return;\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"remove\",\n        descriptor: device.path,\n        deviceModel,\n        device,\n      });\n    };\n    events.on(\"add\", onAdd);\n    events.on(\"remove\", onRemove);\n    function unsubscribe() {\n      unsubscribed = true;\n      events.removeListener(\"add\", onAdd);\n      events.removeListener(\"remove\", onRemove);\n      stop();\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * if path=\"\" is not provided, the library will take the first device\n   */\n  static open(path: ?string) {\n    return Promise.resolve().then(() => {\n      if (path) {\n        return new TransportNodeHid(new HID.HID(path));\n      }\n      const device = getDevices()[0];\n      if (!device) throw new TransportError(\"NoDevice\", \"NoDevice\");\n      return new TransportNodeHid(new HID.HID(device.path));\n    });\n  }\n}\n"],"file":"TransportNodeHid.js"}